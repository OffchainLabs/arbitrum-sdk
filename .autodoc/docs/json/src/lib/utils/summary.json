{
  "folderName": "utils",
  "folderPath": ".autodoc/docs/json/src/lib/utils",
  "url": "https://github.com/offchainlabs/arbitrum-sdk/.autodoc/docs/json/src/lib/utils",
  "files": [
    {
      "fileName": "arbProvider.ts",
      "filePath": "src/lib/utils/arbProvider.ts",
      "url": "https://github.com/offchainlabs/arbitrum-sdk/src/lib/utils/arbProvider.ts",
      "summary": "The code defines a custom formatter and provider for the Arbitrum network. The `ArbFormatter` class extends the `Formatter` class from the `@ethersproject/providers` package and overrides some of its methods to provide custom formatting for certain data entities specific to the Arbitrum network. The `ArbitrumProvider` class extends the `Web3Provider` class from the same package and overrides some of its methods to use the custom formatter and return data entities specific to the Arbitrum network.\n\nThe `ArbFormatter` class overrides the `getDefaultFormats()` method to add custom formatting for `ArbBlock` and `ArbTransactionReceipt` entities. It first calls the `getDefaultFormats()` method of the super class to get the default formatting for all entities. It then adds custom formatting for `ArbBlock` and `ArbTransactionReceipt` entities by defining new properties for them. Finally, it returns the updated formats object.\n\nThe `ArbFormatter` class also overrides the `receipt()`, `block()`, and `blockWithTransactions()` methods to cast the return value of the super class to the custom `ArbTransactionReceipt` and `ArbBlock` types.\n\nThe `ArbitrumProvider` class defines a static `arbFormatter` property that holds an instance of the `ArbFormatter` class. It overrides the `getFormatter()` method to return this custom formatter. It also overrides the `getBlock()`, `getBlockWithTransactions()`, and `getTransactionReceipt()` methods to cast the return value of the super class to the custom `ArbBlock`, `ArbBlockWithTransactions`, and `ArbTransactionReceipt` types, respectively.\n\nThis code can be used in the larger project to interact with the Arbitrum network using the `@ethersproject/providers` package. Developers can create an instance of the `ArbitrumProvider` class by passing in a `JsonRpcProvider` instance that is connected to an Arbitrum network and an optional network name. They can then use this provider to interact with the Arbitrum network and get custom-formatted data entities specific to the network. For example, they can call the `getBlock()` method to get an `ArbBlock` entity that contains additional properties specific to the Arbitrum network.",
      "questions": "1. What is the purpose of the `ArbFormatter` class?\n- The `ArbFormatter` class extends the `Formatter` class from the `@ethersproject/providers` package and overrides some of its methods to add Arbitrum-specific formatting options for blocks and receipts.\n\n2. What is the purpose of the `ArbitrumProvider` class?\n- The `ArbitrumProvider` class extends the `Web3Provider` class from the `@ethersproject/providers` package and adds Arbitrum-specific functionality for getting transaction receipts and blocks with transactions.\n\n3. Why does the `getBlockWithTransactions` method in `ArbitrumProvider` return a `Promise<ArbBlockWithTransactions>` instead of just an `ArbBlockWithTransactions`?\n- The `getBlockWithTransactions` method is an asynchronous method that returns a promise, so it needs to be awaited or handled with `.then()` to get the actual result. The return type is specified as `Promise<ArbBlockWithTransactions>` to indicate that it is a promise that resolves to an `ArbBlockWithTransactions` object."
    },
    {
      "fileName": "byte_serialize_params.ts",
      "filePath": "src/lib/utils/byte_serialize_params.ts",
      "url": "https://github.com/offchainlabs/arbitrum-sdk/src/lib/utils/byte_serialize_params.ts",
      "summary": "This file is part of the Arbitrum SDK project and contains code for byte serialization of Solidity arguments schema. The purpose of this code is to provide methods for serializing parameters for a Solidity method into a single byte array to minimize calldata. The code uses a specific schema for serializing Solidity arguments, which is described in detail in the code comments.\n\nThe code exports two functions: `argSerializerConstructor` and `serializeParams`. `argSerializerConstructor` is a higher-order function that takes an `arbProvider` and returns a function that can be used to serialize Solidity arguments. The returned function takes an array of primitive or primitive arrays as input and returns a `Uint8Array` of serialized arguments.\n\n`serializeParams` is a function that takes an array of primitive or primitive arrays as input and returns a `Uint8Array` of serialized arguments. This function can be used directly to serialize Solidity arguments.\n\nThe code also exports a `getAddressIndex` function that takes an address and a signer or provider as input and returns the index of the address in the address table. The address table is a contract that maps Ethereum addresses to indices. This function is used internally by `serializeParams` to serialize addresses.\n\nThe code uses several external dependencies, including `@ethersproject/abstract-provider`, `@ethersproject/abstract-signer`, `@ethersproject/address`, `@ethersproject/bytes`, `@ethersproject/bignumber`, and `ArbAddressTable__factory`. These dependencies are used for various purposes, including formatting primitive types, checking if an input is an address, and interacting with the address table contract.\n\nOverall, this code provides a useful utility for serializing Solidity arguments into a single byte array, which can help minimize calldata and improve performance. It is an important part of the Arbitrum SDK project and can be used in various ways to interact with the Arbitrum network.",
      "questions": "1. What is the purpose of this code?\n- This code provides methods for serializing parameters for a Solidity method into a single byte array to minimize calldata.\n\n2. What is the schema used for serializing address[] and non-address[]?\n- For address[], the schema includes length (1 byte), is-registered (1 byte), and addresses (4 or 20 bytes). For non-address[], the schema includes length (1 byte) and items (variable).\n\n3. What is the purpose of the `getAddressIndex` function?\n- The `getAddressIndex` function returns the index of an address in the address table, or -1 if the address is not registered."
    },
    {
      "fileName": "eventFetcher.ts",
      "filePath": "src/lib/utils/eventFetcher.ts",
      "url": "https://github.com/offchainlabs/arbitrum-sdk/src/lib/utils/eventFetcher.ts",
      "summary": "The `EventFetcher` class in the `arbitrum-sdk` project is responsible for fetching and parsing blockchain logs. It is designed to work with the `@ethersproject/abstract-provider` and `@ethersproject/contracts` packages, as well as the `TypeChainContractFactory` and `TypedEventFilter` types from the `../dataEntities/event` module.\n\nThe `EventFetcher` class has a single public method, `getEvents`, which takes three parameters: a `TypeChainContractFactory` for generating a contract of type `TContract` at a given address, a generator function for creating a `TypedEventFilter` of type `TEventFilter` for the contract, and a filter object containing block and address filter parameters. The method returns a promise that resolves to an array of `FetchedEvent` objects.\n\nThe `FetchedEvent` type represents a parsed blockchain log and contains information such as the event data, topic, name, block number, block hash, transaction hash, address, topics, and data.\n\nThe `getEvents` method first connects to the contract at the given address using the `TypeChainContractFactory` and `Provider` objects. It then generates a `TypedEventFilter` using the provided generator function and creates a `Filter` object containing the filter parameters. The method then calls the `getLogs` method of the `Provider` object to fetch the logs that match the filter. It filters out any logs that have been removed and maps the remaining logs to `FetchedEvent` objects.\n\nOverall, the `EventFetcher` class provides a convenient way to fetch and parse blockchain logs for a given contract and event filter. It can be used in the larger project to monitor and analyze events on the blockchain. Here is an example usage of the `EventFetcher` class:\n\n```typescript\nimport { ethers } from 'ethers'\nimport { EventFetcher } from 'arbitrum-sdk'\n\nconst provider = new ethers.providers.JsonRpcProvider('http://localhost:8545')\nconst eventFetcher = new EventFetcher(provider)\n\nconst contractFactory = new ethers.ContractFactory(\n  abi,\n  bytecode,\n  provider.getSigner()\n)\n\nconst topicGenerator = (contract) => contract.filters.MyEvent()\n\nconst filter = {\n  fromBlock: 0,\n  toBlock: 'latest',\n  address: '0x1234567890123456789012345678901234567890'\n}\n\neventFetcher.getEvents(contractFactory, topicGenerator, filter)\n  .then((events) => {\n    console.log(events)\n  })\n  .catch((error) => {\n    console.error(error)\n  })\n```",
      "questions": "1. What is the purpose of this code?\n- This code defines a class called `EventFetcher` that fetches and parses blockchain logs using ethers.js.\n\n2. What is the `getEvents` method used for?\n- The `getEvents` method is used to fetch and parse logs for a specific contract and event filter within a specified block range.\n\n3. Why is there a custom type called `TEventOf` defined in this code?\n- The `TEventOf` type is defined to correctly infer the event type for the `getEvents` method, as the method was not able to properly infer the event return type without it."
    },
    {
      "fileName": "lib.ts",
      "filePath": "src/lib/utils/lib.ts",
      "url": "https://github.com/offchainlabs/arbitrum-sdk/src/lib/utils/lib.ts",
      "summary": "This file contains utility functions that are used in the larger arbitrum-sdk project. The functions are exported and can be imported into other files in the project. \n\nThe `wait` function is a simple utility function that takes a number of milliseconds as an argument and returns a promise that resolves after that amount of time has passed. This function can be used to introduce delays in code execution.\n\nThe `getBaseFee` function takes a provider object as an argument and returns the base fee per gas for the latest block. It does this by calling the `getBlock` method on the provider object and extracting the `baseFeePerGas` property from the result. If the `baseFeePerGas` property is not defined, an `ArbSdkError` is thrown. This function can be used to get the base fee per gas for a given network.\n\nThe `getTransactionReceipt` function takes a provider object, a transaction hash, an optional number of confirmations, and an optional timeout as arguments. If either the `confirmations` or `timeout` argument is defined, the function waits for the transaction receipt using the `waitForTransaction` method on the provider object. If the receipt is not received within the specified timeout, the function returns null. If neither `confirmations` nor `timeout` is defined, the function simply fetches the transaction receipt using the `getTransactionReceipt` method on the provider object. This function can be used to get the transaction receipt for a given transaction hash.\n\nThe `isDefined` function is a type guard that takes a value as an argument and returns a boolean indicating whether the value is defined (i.e., not null or undefined). This function can be used to check whether a value is defined before using it in code.\n\nOverall, these utility functions provide useful functionality that can be used throughout the arbitrum-sdk project.",
      "questions": "1. What is the purpose of the `wait` function?\n- The `wait` function is a utility function that returns a promise that resolves after a specified number of milliseconds.\n\n2. What is the `getBaseFee` function doing?\n- The `getBaseFee` function takes a provider object as input and returns the base fee per gas for the latest block. If the base fee is not available, it throws an `ArbSdkError`.\n\n3. What is the purpose of the `isDefined` function?\n- The `isDefined` function is a type guard that checks if a value is not null or undefined, and returns a boolean indicating whether the value is defined or not. It takes a generic type `T` as input and returns a type predicate that asserts that a value is of type `T`."
    },
    {
      "fileName": "multicall.ts",
      "filePath": "src/lib/utils/multicall.ts",
      "url": "https://github.com/offchainlabs/arbitrum-sdk/src/lib/utils/multicall.ts",
      "summary": "The `MultiCaller` class in this code is a utility for executing multiple calls against the MultiCallV2 contract in the Arbitrum SDK. It is designed to efficiently fetch token properties and other data from the Ethereum blockchain using a single contract call, reducing the number of requests and improving performance.\n\nThe `MultiCaller` class provides several methods:\n\n- `fromProvider(provider: Provider)`: Instantiates a `MultiCaller` instance with the correct multicall address for the given provider.\n- `getBlockNumberInput()`: Returns the call input for the current block number.\n- `getCurrentBlockTimestampInput()`: Returns the call input for the current block timestamp.\n- `multiCall(params: T, requireSuccess?: TRequireSuccess)`: Executes a multicall for the given parameters. If `requireSuccess` is true, the whole call will fail if any internal call fails.\n- `getTokenData(erc20Addresses: string[], options?: T)`: Multicall for token properties. Collects all the requested properties for each of the supplied token addresses.\n\nHere's an example of how to use the `MultiCaller` class:\n\n```typescript\nconst multiCaller = await MultiCaller.fromProvider(provider)\n\nconst inputs: [\n  CallInput<Awaited<ReturnType<ERC20['functions']['balanceOf']>>[0]>,\n  CallInput<Awaited<ReturnType<ERC20['functions']['name']>>[0]>\n] = [\n  {\n    targetAddr: token.address,\n    encoder: () => token.interface.encodeFunctionData('balanceOf', ['']),\n    decoder: (returnData: string) =>\n      token.interface.decodeFunctionResult('balanceOf', returnData)[0],\n  },\n  {\n    targetAddr: token.address,\n    encoder: () => token.interface.encodeFunctionData('name'),\n    decoder: (returnData: string) =>\n      token.interface.decodeFunctionResult('name', returnData)[0],\n  },\n]\n\nconst res = await multiCaller.call(inputs)\n```\n\nIn this example, the `MultiCaller` instance is created using the `fromProvider` method, and then two call inputs are created for fetching the balance and name of a token. The `multiCall` method is used to execute these calls, and the results are returned in the `res` variable.",
      "questions": "1. **Question**: What is the purpose of the `MultiCaller` class and how does it work with the MultiCallV2 contract?\n   **Answer**: The `MultiCaller` class is a utility for executing multiple calls against the MultiCallV2 contract. It helps in aggregating multiple contract calls into a single call, reducing the number of requests and improving efficiency. It provides methods for fetching block number, block timestamp, and token data using multicalls.\n\n2. **Question**: How does the `getTokenData` method work and what are the possible options that can be passed to it?\n   **Answer**: The `getTokenData` method is used to fetch token properties for the given ERC20 token addresses using multicalls. It accepts an array of token addresses and an optional `options` parameter. The `options` parameter can include properties like `balanceOf`, `allowance`, `symbol`, `decimals`, and `name`. The method returns an array of objects containing the requested token properties.\n\n3. **Question**: How can a developer use the `multiCall` method to execute multiple calls with different types and get better type inference for the results?\n   **Answer**: To get better type inference when the individual calls are of different types, a developer can create the inputs as a tuple and pass the tuple to the `multiCall` method. The return type will be a tuple of the decoded return types. An example is provided in the code comments to demonstrate how to create a tuple of inputs and use it with the `multiCall` method."
    },
    {
      "fileName": "types.ts",
      "filePath": "src/lib/utils/types.ts",
      "url": "https://github.com/offchainlabs/arbitrum-sdk/src/lib/utils/types.ts",
      "summary": "This file contains three type definitions: OmitTyped, PartialPick, and RequiredPick. These types are used to manipulate object types in TypeScript.\n\nOmitTyped is used to create a new type that omits a specified set of properties from an existing type. The second generic parameter, K, specifies which properties to omit. However, unlike the built-in Omit type, OmitTyped does not enforce that K is a keyof T. This means that it is possible to omit properties that do not exist on the original type. OmitTyped is useful when you want to remove a set of properties from an object type, but you don't want to be restricted to only omitting properties that actually exist on the type.\n\nHere is an example of how OmitTyped can be used:\n\n```\ninterface Person {\n  name: string;\n  age: number;\n  email: string;\n}\n\ntype PersonWithoutEmail = OmitTyped<Person, 'email'>;\n\n// PersonWithoutEmail is equivalent to:\n// interface PersonWithoutEmail {\n//   name: string;\n//   age: number;\n// }\n```\n\nPartialPick is used to create a new type that makes a specified set of properties optional. The second generic parameter, K, specifies which properties to make optional. PartialPick uses OmitTyped to remove the specified properties from the original type, and then uses the built-in Partial type to make the remaining properties optional.\n\nHere is an example of how PartialPick can be used:\n\n```\ninterface Person {\n  name: string;\n  age: number;\n  email: string;\n}\n\ntype PersonWithOptionalEmail = PartialPick<Person, 'email'>;\n\n// PersonWithOptionalEmail is equivalent to:\n// interface PersonWithOptionalEmail {\n//   name: string;\n//   age: number;\n//   email?: string;\n// }\n```\n\nRequiredPick is used to create a new type that makes a specified set of properties required. The second generic parameter, K, specifies which properties to make required. RequiredPick uses the built-in Pick type to select the specified properties from the original type, and then uses the built-in Required type to make those properties required.\n\nHere is an example of how RequiredPick can be used:\n\n```\ninterface Person {\n  name: string;\n  age?: number;\n  email?: string;\n}\n\ntype PersonWithRequiredName = RequiredPick<Person, 'name'>;\n\n// PersonWithRequiredName is equivalent to:\n// interface PersonWithRequiredName {\n//   name: string;\n//   age?: number;\n//   email?: string;\n// }\n// However, the 'name' property is now required.\n```",
      "questions": "1. What is the purpose of the `OmitTyped` type and how does it differ from the `Omit` type?\n- The purpose of `OmitTyped` is to guard against refactoring of underlying type property names, while `Omit` does not enforce that the second generic is a keyof the first.\n\n2. What does the `PartialPick` type do?\n- `PartialPick` makes the specified properties optional by using `OmitTyped` to remove the specified properties from `T` and then adding them back as optional properties using `Partial`.\n\n3. What does the `RequiredPick` type do?\n- `RequiredPick` makes the specified properties required by using `Pick` to select the specified properties from `T` and then making them required using `Required`, before merging them back with the original type `T`."
    }
  ],
  "folders": [],
  "summary": "The `utils` folder in the `arbitrum-sdk` project contains utility functions and classes that are used throughout the project to interact with the Arbitrum network and handle various tasks such as formatting, serialization, event fetching, and multicall execution.\n\nFor example, the `ArbFormatter` and `ArbitrumProvider` classes in `arbProvider.ts` are used to provide custom formatting for certain data entities specific to the Arbitrum network. Developers can create an instance of the `ArbitrumProvider` class and use it to interact with the Arbitrum network and get custom-formatted data entities, such as calling the `getBlock()` method to get an `ArbBlock` entity with additional properties specific to the network.\n\nThe `byte_serialize_params.ts` file provides methods for serializing parameters for a Solidity method into a single byte array to minimize calldata. Developers can use the `argSerializerConstructor` and `serializeParams` functions to serialize Solidity arguments, which can help improve performance when interacting with the Arbitrum network.\n\nThe `EventFetcher` class in `eventFetcher.ts` is responsible for fetching and parsing blockchain logs. Developers can use this class to monitor and analyze events on the blockchain. For example, they can create an instance of the `EventFetcher` class and call the `getEvents()` method to fetch and parse logs for a given contract and event filter.\n\nUtility functions in `lib.ts` provide useful functionality such as introducing delays in code execution (`wait`), getting the base fee per gas for a given network (`getBaseFee`), and checking whether a value is defined before using it in code (`isDefined`).\n\nThe `MultiCaller` class in `multicall.ts` is a utility for executing multiple calls against the MultiCallV2 contract, reducing the number of requests and improving performance. Developers can use this class to efficiently fetch token properties and other data from the Ethereum blockchain using a single contract call.\n\nLastly, the `types.ts` file contains type definitions such as `OmitTyped`, `PartialPick`, and `RequiredPick` that are used to manipulate object types in TypeScript. These types can be used throughout the project to create new types based on existing ones with specific properties omitted, made optional, or made required.\n\nOverall, the `utils` folder provides essential utility functions and classes that are used throughout the `arbitrum-sdk` project to interact with the Arbitrum network and handle various tasks. These utilities help developers efficiently work with the network and improve the performance of their interactions.",
  "questions": ""
}